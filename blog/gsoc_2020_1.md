# Google Summer of Code 2020 - First month

I am very happy to be part of the GSoC 2020 at Mozilla to support [`rav1e`](https://github.com/xiph/rav1e) "The fastest and safest AV1 encoder".

- [rav1e](#rav1e)
  - [video encoder](#video-encoder)
  - [AV1](#av1)
  - [rust](#rust)
- [My project](#my-project)
  - [Steps to achieve this](#steps-to-achieve-this)
- [My journey (so far)](#my-journey-so-far)
  - [Getting comfortable](#getting-comfortable)
  - [Proof of concept](#proof-of-concept)
  - [jsapi v0.1](#jsapi-v01)
    - [goal](#goal)
    - [design](#design)
      - [fluent-ffmpeg](#fluent-ffmpeg)
      - [ffmpeg.wasm](#ffmpegwasm)
    - [implementation](#implementation)
  - [next steps](#next-steps)
- [mentors](#mentors)
- [Citations](#citations)

## rav1e
The most important thing first: The name is an abbreviation for "rust AV1 encoder".

As the name suggests `rav1e` is a video encoder for the [AV1 video coding format](https://en.wikipedia.org/wiki/AV1), written in [rust](https://www.rust-lang.org/).

### video encoder
Simply spoken a video encoder takes uncompressed video as an input, compresses it and outputs a video way tinier in size. This output is handier than the input and can be for example saved to disk or distributed over the network. Later it can be decompressed using a video decoder (e.g. [`dav1d`](https://code.videolan.org/videolan/dav1d)) to get back to the original video quality.

Under the hood it is very complex from a mathematical and software engineering-perspective, but to be honest I don't fully get it yet.

### AV1
> AOMedia Video 1 [...] is an open, royalty-free video coding format designed for video transmissions over the Internet. It was developed [...] by the Alliance for Open Media (AOMedia), a consortium founded in 2015 that includes semiconductor firms, video on demand providers, video content producers, software development companies and web browser vendors.
> [‚ÅΩ¬π‚Åæ](#citations)

Mozilla is a governing member of AOMedia.

### rust
"Rust is a multi-paradigm programming language focused on performance and safety" [‚ÅΩ¬≤‚Åæ](#citations).

It is actually one reason I choose to apply for this project, because I think I can learn a programming language best by applying it in a real world project.

## My project
The goal of my project is to enable and improve [`webassembly (wasm)`](https://webassembly.org/) support of `rav1e`, mainly to make it usable as an in-browser encoder.

### Steps to achieve this
1. build a JavaScript/TypeScript API for `rav1e` _(well documented and tested, of course üòâ)_
2. profile wasm target (size and time)
3. improve wasm target based on profiling
4. provide demo applications for various platforms (vanilla js/ts, [node.js](https://nodejs.org/), [react.js](https://reactjs.org/), [`yew`](https://github.com/yewstack/yew), [`deno`](https://github.com/denoland/deno))

## My journey (so far)

### Getting comfortable
Before starting to work on my actual project, I familiarized myself with the codebase, community and the overall domain of video processing. To do so I took on some small issues ([`#2328`](https://github.com/xiph/rav1e/pull/2328), [`#2344`](https://github.com/xiph/rav1e/pull/2344)) and read a lot about video encoding. I got good feedback to my PRs on GitHub and also on IRC. Already in that stage I noticed how responsive and willing to help the rav1e contributors are.

### Proof of concept
The next step was a proof of concept for the js-api. I am building it with [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), an alternative would be [`stdweb`](https://github.com/koute/stdweb).

`wasm-bindgen` let's you:
> Facilitat[e] high-level interactions between Wasm modules and JavaScript [and] [i]mport JavaScript things into Rust and export Rust things to JavaScript.
> [‚ÅΩ¬≥‚Åæ](#citations)

write rust code and expose specific functions, structs and enums to JavaScript. In the background rust gets compiled to wasm (`--target wasm32-unknown-unknown`). Additionally wasm-bindgen creates functionality to pass data across the wasm-ABI and also adds bindings for javascript. This makes it possible to control everything from the JS side, but still do the heavy lifting with somewhat native performance on the wasm side.

This first version only exposes one function `simple_encoding(repeats: u32)`. It instantiates an encoder, feeds it multiple blank frames, encodes them and logs the received packets. <br>

<details>
<summary>Find the actual implementation in <a href="https://github.com/xiph/rav1e/pull/2382"><code>#2344</code></a> and a simplified version here</summary>

**Rust**
```rust
fn simple_encoding(repeats: u32) {
    // this is our encoder
    let ctx: Context<u16> = Config::new()
        .with_encoder_config(EncoderConfig::default())
        .new_context().unwrap();

    // let's send multiple blank frames to the encoder
    let f: Frame<u16> = ctx.new_frame();
    for i in 0..repeats {
        ctx.send_frame(f.clone()).unwrap();
    }

    // we tell the encoder, that we are done sending input
    ctx.flush()

    // and now we encode all frames and log the received packets
    loop {
        match ctx.receive_packet() {
            Ok(packet) => log!("Received packet: {}", packet),
            Err(EncoderStatus::Encoded) => {}
            Err(EncoderStatus::LimitReached) => break,
            Err(e) => panic!(e);
        }
    }
}
```

**JavaScript**
```ts
import { simple_encoding } from "rav1e";

simple_encoding(5);
```

**Website**
![](img/jsapi-v0.0.png)
</details>

Also the PR introduces some checks for the CI.

### jsapi v0.1
After the proof of concept landed, I sat on designing and implementing `v0.1` of the actual API.

#### goal
The goal was to rebuild the functionality of `simple_encoding(...)`, but controlled from the js side.

#### design
As suggested by `lu_zero` I researched existing encoder APIs. The goal was to build a familiar interface users already know.

Find the results of the research [here](https://www.notion.so/urhengulas/API-Design-0dfc787efe4649ac9d2fae45d1e8ff84).

During my research, I firstly I noticed that there are not that many media encoders in JavaScript and often they are "just" wrapper around encoding tools (e.g. [`ffmpeg`](https://ffmpeg.org/ffmpeg.html) (written in C/C++)). On main reason for that is probably the high computing power encoders demand, which is not exactly given by interpreted languages like JavaScript.

##### fluent-ffmpeg
The API I think is best to take as a role model is [`fluent-ffmpeg`](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg) (only works in node.js with ffmpeg present).

What i like about it:
* configuration via trailable methods
* event handlers like 'progress' (transcoding progress information), or 'end' (processing finished)
* multiple ways to put your data in (uploaded file, `fs.ReadStream` )

<details>
<summary>fluent-ffmpeg example</summary>

```ts
const enc: FfmpegCommand = ffmpeg('/path/to/your_movie.avi')
  // video options
  .videoBitrate(1024).videoCodec('divx').aspect('16:9')
  .size('50%')       .fps(24)
  // audio options
  .noAudio()
  // output options
  .format('avi')
  // event handler
  .on('end', function() {
    console.log('file has been converted succesfully');
  })
  .on('error', function(err) {
    console.log('an error happened: ' + err.message);
  });

const outStream = fs.createWriteStream('/path/to/output.avi');

// start processing and write to stream
enc.pipe(outStream, {end: true});
```
</details>

##### ffmpeg.wasm
Another noteworthy one is [`ffmpeg.wasm`](https://github.com/ffmpegwasm/ffmpeg.wasm), which is a bit similar to what the goal of my project is. It's a js library based on webassembly (ports ffmpeg (C/C++) via [emscripten](https://emscripten.org/)).

#### implementation
As I said before the API is build using `wasm-bindgen`.

### next steps
Do great stuff :)

## mentors
My mentor for this project is Nathan Egge (Video Codec Engineer at Mozilla, [`negge` on GitHub](https://github.com/negge)).

Additionally I get support by other rav1e supporter, especially noteworthy Luca Barbato ([`lu_zero` on GitHub](https://github.com/lu-zero)) and Vibhoothi ([`vibhoothiiaanand` on GitHub](https://github.com/vibhoothiiaanand), but else `mindfreeze`).

A big thank you to all of you üòä

## Citations
1. AV1. (2020, June 29). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/AV1
2. Rust (programming language). (2020, June 25). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/Rust_(programming_language)
3. Rustwasm. (2020, March 17). Rustwasm/wasm-bindgen. Retrieved June 30, 2020, from https://github.com/rustwasm/wasm-bindgen/blob/master/README.md