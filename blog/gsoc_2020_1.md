# Google Summer of Code 2020 - First month

I am very happy to be part of the GSoC 2020 at Mozilla to support [`rav1e`](https://github.com/xiph/rav1e) "The fastest and safest AV1 encoder".

## rav1e
The most important thing first: The name is an abbreviation for "rust AV1 encoder".

As the name suggests `rav1e` is a video encoder for the [AV1 video coding format](https://en.wikipedia.org/wiki/AV1), written in [rust](https://www.rust-lang.org/).

### video encoder
Simply spoken a video encoder takes uncompressed video as an input, compresses it and outputs a video way tinier in size. This output is handier than the input and can be for example saved to disk or distributed over the network. Later it can be decompressed using a video decoder (e.g. [`dav1d`](https://code.videolan.org/videolan/dav1d)) to get back to the original video quality.

Under the hood it is very complex from a mathematical and software engineering-perspective, but to be honest I don't fully get it yet.

### AV1
> AOMedia Video 1 [...] is an open, royalty-free video coding format designed for video transmissions over the Internet. It was developed [...] by the Alliance for Open Media (AOMedia), a consortium founded in 2015 that includes semiconductor firms, video on demand providers, video content producers, software development companies and web browser vendors.
> [‚ÅΩ¬π‚Åæ](#citations)

Mozilla is a governing member of AOMedia.

### rust
"Rust is a multi-paradigm programming language focused on performance and safety" [‚ÅΩ¬≤‚Åæ](#citations).

It is actually one reason I choose to apply for this project, because I think I can learn a programming language best by applying it in a real world project.

## My project
The goal of my project is to enable and improve [`webassembly (wasm)`](https://webassembly.org/) support of `rav1e`, mainly to make it usable as an in-browser encoder.

### Steps to achieve this
1. build a JavaScript/TypeScript API for `rav1e` _(well documented and tested, of course üòâ)_
2. profile wasm target (size and time)
3. improve wasm target based on profiling
4. provide demo applications for various platforms (vanilla js/ts, node.js, react.js, [`yew`](https://github.com/yewstack/yew), [`deno`](https://github.com/denoland/deno))

## My journey (so far)
### Getting comfortable
Before starting to work on my actual project, I familiarized myself with the codebase, community and the overall domain of video processing. To do so I took on some small issues ([`#2328`](https://github.com/xiph/rav1e/pull/2328), [`#2344`](https://github.com/xiph/rav1e/pull/2344)) and read a lot about video encoding. I got good feedback to my PRs on GitHub and also on IRC. Already in that stage I noticed how responsive and willing to help the rav1e contributors are.

### Proof of concept
The next step was a proof of concept for the js-api. I am building it with [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), an alternative would be [`stdweb`](https://github.com/koute/stdweb).

In the end the rust code gets compiled to wasm (`--target wasm32-unknown-unknown`). Additionally wasm-bindgen creates functionality to pass data across the wasm-ABI and also adds bindings for javascript. This makes it possible to control everything from the JS side, but still do the heavy lifting with somewhat native performance on the wasm side.

This first version only exposes one function `simple_encoding(repeats: u32)`. It instantiates an encoder, feeds it multiple blank frames, encodes them and logs the received packets. <br>

<details>
<summary>Find the actual implementation in <a href="https://github.com/xiph/rav1e/pull/2382"><code>#2344</code></a> and a simplified version here</summary>

**Rust**
```rust
fn simple_encoding(repeats: u32) {
    // this is our encoder
    let ctx: Context<u16> = Config::new()
        .with_encoder_config(EncoderConfig::default())
        .new_context().unwrap();

    // let's send multiple blank frames to the encoder
    let f: Frame<u16> = ctx.new_frame();
    for i in 0..repeats {
        ctx.send_frame(f.clone()).unwrap();
    }

    // we tell the encoder, that we are done sending input
    ctx.flush()

    // and now we encode all frames and log the received packets
    loop {
        match ctx.receive_packet() {
            Ok(packet) => log!("Received packet: {}", packet),
            Err(EncoderStatus::Encoded) => {}
            Err(EncoderStatus::LimitReached) => break,
            Err(e) => panic!(e);
        }
    }
}
```

**JavaScript**
```ts
import { simple_encoding } from "rav1e";

simple_encoding(5);
```

**Website**
![](img/jsapi-v0.0.png)
</details>

### jsapi v0.1
...

## Citations
1. AV1. (2020, June 29). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/AV1
2. Rust (programming language). (2020, June 25). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/Rust_(programming_language)