# Google Summer of Code 2020 - First month

I am very happy to be part of the GSoC 2020 at Mozilla to support [`rav1e`](https://github.com/xiph/rav1e) "The fastest and safest AV1 encoder".

- [rav1e](#rav1e)
  - [video encoder](#video-encoder)
  - [AV1](#av1)
  - [rust](#rust)
- [My project](#my-project)
  - [Steps to achieve this](#steps-to-achieve-this)
- [My journey (so far)](#my-journey-so-far)
  - [Getting comfortable](#getting-comfortable)
  - [Proof of concept](#proof-of-concept)
  - [jsapi v0.1](#jsapi-v01)
    - [goal](#goal)
    - [design](#design)
    - [implementation](#implementation)
  - [next steps](#next-steps)
- [mentors](#mentors)
- [Citations](#citations)

## rav1e
The most important thing first: The name is an abbreviation for "rust AV1 encoder".

As the name suggests `rav1e` is a video encoder for the [AV1 video coding format](https://en.wikipedia.org/wiki/AV1), written in [rust](https://www.rust-lang.org/).

### video encoder
Simply spoken a video encoder takes uncompressed video as an input, compresses it and outputs a video way tinier in size. This output is handier than the input and can be for example saved to disk or distributed over the network. Later it can be decompressed using a video decoder (e.g. [`dav1d`](https://code.videolan.org/videolan/dav1d)) to get back to the original video quality.

Under the hood it is very complex from a mathematical and software engineering-perspective, but to be honest I don't fully get it yet.

### AV1
> AOMedia Video 1 [...] is an open, royalty-free video coding format designed for video transmissions over the Internet. It was developed [...] by the Alliance for Open Media (AOMedia), a consortium founded in 2015 that includes semiconductor firms, video on demand providers, video content producers, software development companies and web browser vendors.
> [‚ÅΩ¬π‚Åæ](#citations)

Mozilla is a governing member of AOMedia.

### rust
"Rust is a multi-paradigm programming language focused on performance and safety" [‚ÅΩ¬≤‚Åæ](#citations).

It is actually one reason I choose to apply for this project, because I think I can learn a programming language best by applying it in a real world project.

## My project
The goal of my project is to enable and improve [`webassembly (wasm)`](https://webassembly.org/) support of `rav1e`, mainly to make it usable as an in-browser encoder.

### Steps to achieve this
1. build a JavaScript/TypeScript API for `rav1e` _(well documented and tested, of course üòâ)_
2. profile wasm target (size and time)
3. improve wasm target based on profiling
4. provide demo applications for various platforms (vanilla js/ts, [node.js](https://nodejs.org/), [react.js](https://reactjs.org/), [yew](https://github.com/yewstack/yew), [deno](https://github.com/denoland/deno))

## My journey (so far)

### Getting comfortable
Before starting to work on my actual project, I familiarized myself with the codebase, community and the overall domain of video processing. To do so I took on some small issues ([`#2328`](https://github.com/xiph/rav1e/pull/2328), [`#2344`](https://github.com/xiph/rav1e/pull/2344)) and read a lot about video encoding. I got good feedback to my PRs on GitHub and also on IRC. Already in that stage I noticed how responsive and willing to help the rav1e contributors are.

### Proof of concept
The next step was a proof of concept for the js-api. I am building it with [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), an alternative would be [`stdweb`](https://github.com/koute/stdweb).

`wasm-bindgen` let's you:
> Facilitat[e] high-level interactions between Wasm modules and JavaScript [and] [i]mport JavaScript things into Rust and export Rust things to JavaScript.
> [‚ÅΩ¬≥‚Åæ](#citations)

In the background rust gets compiled to wasm (`--target wasm32-unknown-unknown`). Additionally wasm-bindgen creates functionality to pass data across the wasm-ABI and also adds bindings for javascript. This makes it possible to control everything from the JS side, but still do the heavy lifting with somewhat native performance on the wasm side.

This first version only exposes one function `simple_encoding(repeats: u32)`. It instantiates an encoder, feeds it multiple blank frames, encodes them and logs the received packets. <br>

<details>
<summary>Find the actual implementation in <a href="https://github.com/xiph/rav1e/pull/2382"><code>#2382</code></a> and a simplified version by clicking here</summary>

**Rust**
```rust
use rav1e::prelude::*;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
fn simple_encoding(repeats: u32) {
    // this is our encoder
    let ctx: Context<u16> = Config::new()
        .with_encoder_config(EncoderConfig::default())
        .new_context().unwrap();

    // let's send multiple blank frames to the encoder
    let f: Frame<u16> = ctx.new_frame();
    for i in 0..repeats {
        ctx.send_frame(f.clone()).unwrap();
    }

    // we tell the encoder, that we are done sending input
    ctx.flush()

    // and now we encode all frames and log the received packets
    loop {
        match ctx.receive_packet() {
            Ok(packet) => log!("Received packet: {}", packet),
            Err(EncoderStatus::Encoded) => {}
            Err(EncoderStatus::LimitReached) => break,
            Err(e) => panic!(e);
        }
    }
}
```

**JavaScript**
```ts
import { simple_encoding } from "rav1e";

// encodes 5 frames
simple_encoding(5);
```

**Website**
![](img/jsapi-v0.0.png)
</details>

Also the PR introduces some checks for the CI.

### jsapi v0.1
After the proof of concept landed, I sat on designing and implementing `v0.1` of the actual API.

#### goal
The goal was to rebuild the functionality of `simple_encoding(...)`, but controlled from the js side.

#### design
As suggested by `lu_zero` I started by researching existing encoder APIs. The goal was to build a familiar interface users feel comfortable with.

Find the results of the research [on notion](https://www.notion.so/urhengulas/API-Design-0dfc787efe4649ac9d2fae45d1e8ff84).

During my research, I firstly noticed that there are not that many media encoders in JavaScript and often they are "just" wrapper around encoding tools (e.g. [`ffmpeg`](https://ffmpeg.org/ffmpeg.html) (written in C/C++)). One main reason for that is probably the high computing power encoders demand, which is not exactly given by interpreted languages like JavaScript.

**fluent-ffmpeg**

The API I think is best to take as a role model is [`fluent-ffmpeg`](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg) (only works in node.js with ffmpeg present).

What i like about it:
* configuration via trailable methods
* event handlers like 'progress' (transcoding progress information), or 'end' (processing finished)
* multiple ways to put your data in (uploaded file, `fs.ReadStream` )

<details>
<summary>fluent-ffmpeg example</summary>

```ts
const enc: FfmpegCommand = ffmpeg('/path/to/your_movie.avi')
  // video options
  .videoBitrate(1024).videoCodec('divx').aspect('16:9')
  .size('50%')       .fps(24)
  // audio options
  .noAudio()
  // output options
  .format('avi')
  // event handler
  .on('end', function() {
    console.log('file has been converted succesfully');
  })
  .on('error', function(err) {
    console.log('an error happened: ' + err.message);
  });

const outStream = fs.createWriteStream('/path/to/output.avi');

// start processing and write to stream
enc.pipe(outStream, {end: true});
```
</details>

**ffmpeg.wasm**

Another noteworthy one is [`ffmpeg.wasm`](https://github.com/ffmpegwasm/ffmpeg.wasm), which is a bit similar to what the goal of my project is. It's a js library based on webassembly (ports ffmpeg from C/C++, via [emscripten](https://emscripten.org/)).

#### implementation
As I said before the API is build using `wasm-bindgen`.

Just exposing the existing rav1e-API sadly doesn't work, because as of today wasm-bindgen doesn't support rust generics. The rav1e API uses [`trait v_frame::pixel::Pixel`](https://docs.rs/v_frame/0.1.0/v_frame/pixel/trait.Pixel.html) for types which can be used as a pixel of the frames. Currently these are `u8` and `u16`.

Because of this, and also because there are different requirements for the rust and javascript API, I decided to go for wrapping the needed structs into custom structs and implement the desired methods on them.

So far we got:
```rust
/// Encoder settings which impact the produced bitstream.
pub struct EncoderConfig {
  conf: rav1e::api::config::encoder::EncoderConfig,
}

/// Contains the encoding state.
pub struct Encoder {
  ctx: rav1e::api::context::Context<u16>,
}

/// Represents one video frame.
pub struct Frame {
  f: v_frame::frame::Frame<u16>,
}

/// A packet contains one shown frame together with zero or more additional frames.
pub struct Packet {
  p: rav1e::api::util::Packet<u16>,
}
```

Let's have revisit our encoding example from a before and have a look how the v0.1 look like:
```ts
import { ChromaSamplePosition, Encoder, EncoderConfig, Frame, Packet } from "rav1e";

// this is our encoder
const enc: Encoder = new Encoder(new EncoderConfig()
    .setDim(96, 64)
    .setSpeed(9)
    .setChromaSamplePosition(ChromaSamplePosition.Unknown)
);

// let's send 10 blank frames to the encoder
const f: Frame = enc.newFrame();
for (let i = 0; i < 10; i++) {
    enc.sendFrame(f);
}

// we tell the encoder, that we are done sending input
enc.flush();

// and now we encode all frames and log the received packets
for (let i = 0; i < 20; i++) {
    try {
        const p: Packet = enc.receivePacket();
        console.log(p.display())
    } catch (e) {
        console.warn(e);
    }
}
```

Looks very familiar, doesn't it? The only difference now is that JavaScript is in control and not rust anymore.

### next steps
* feed custom data
* profiling
* multithreading

## mentors
My mentor for this project is Nathan Egge (Video Codec Engineer at Mozilla, [`negge` on GitHub](https://github.com/negge)).

Additionally I get support by other rav1e supporter, especially noteworthy Luca Barbato ([`lu_zero` on GitHub](https://github.com/lu-zero)) and Vibhoothi ([`vibhoothiiaanand` on GitHub](https://github.com/vibhoothiiaanand), but else `mindfreeze`).

A big thank you to all of you üòä

## Citations
1. AV1. (2020, June 29). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/AV1
2. Rust (programming language). (2020, June 25). Retrieved June 30, 2020, from https://en.wikipedia.org/wiki/Rust_(programming_language)
3. Rustwasm. (2020, March 17). Rustwasm/wasm-bindgen. Retrieved June 30, 2020, from https://github.com/rustwasm/wasm-bindgen/blob/master/README.md